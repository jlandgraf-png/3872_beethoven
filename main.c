// Generated by Proteus Visual Designer for Arduino

// Peripheral Configuration Code (Do Not Edit)
//---CONFIG_BEGIN---
#pragma GCC push_options
#pragma GCC optimize ("Os")

#include <core.h> // Required by cpu
#include <cpu.h>
#include <Generic.h>
#include "uLCD_4DGL.h"
#include <string.h>

#pragma GCC pop_options

// Peripheral Constructors
CPU &cpu = Cpu;
GenericButton RESET = GenericButton (2);
GenericButton STOP = GenericButton (2);
GenericButton RECORD = GenericButton (2);
GenericButton STORE = GenericButton (2);
GenericButton PLAY_LIVE = GenericButton (2);
GenericButton pbDance = GenericButton(2);
GenericButton PLAY_RECORDING = GenericButton (2);
RPG FrequencyDial = RPG(8); //Assuming '8' Notes
uLCD_4DGL uLCD(p9,p10,p11); //default constructor for ULCD


void peripheral_setup () {
}

void peripheral_loop() {
}



//---CONFIG_END---
// Flowchart Variables
String var_state;
long var_resetTimer;
float var_motor_1_angle;
float var_motor_2_angle;
float var_motor_1_velocity;
long var_motor_2_velocity;
float var_speaker_out;
float current;
float count_FDIAL;
float direction_FDIAL;

vector <string> stringStates;
stringStates.pushback("stop");
stringStates.pushback("record");
stringStates.pushback("play live")
stringStates.pushback("play recording");





// Flowchart Routines
void chart_SETUP() {

    // Initial variable declarations
   var_state="idle",var_resetTimer=0,var_motor_1_angle=0,var_motor_2_angle=0,var_motor_1_velocity=0,var_motor_2_velocity=0,var_speaker_out=0;
   
   while (true) //MAIN loop
   	{
   
      // Parse the buttons each to determine state, then switch based on state
      chart_checkButtons();
      
      switch (var_state) {
	    case "idle" :
	      string curr_st = "idle"
	   	  print_currState(curr_st);
	      //uLCD.printf("Current State: IDLE\n");
		  chart_idle_event();
		  break;
	    case "stop" :
	      string curr_st = "stop"
	   	  print_currState(curr_st);
	      //uLCD.printf("Current State: STOP\n");
		  chart_stop_event();
		  break;
	     case "record" :
	      string curr_st = "record"
	   	  print_currState(curr_st);
	      //uLCD.printf("Current State: RECORD\n");
		  chart_record_event();
		  break;
	     case "play live" :
	      string curr_st = "play live"
	   	  print_currState(curr_st);
	      //uLCD.printf("Current State: PLAY LIVE\n");
		  chart_play_live_event();
		  break;
	     case "play recording" :
	      string curr_st = "play recording"
	   	  print_currState(curr_st);
	      //uLCD.printf("Current State: PLAY RECORD\n");
		  chart_play_recording_event();
		  break;
      }

   }
}

// Parses buttons to change state. Assumes user does not press multiple buttons in one function call.
// If the user were to press multiple buttons, the button closest to the bottom would determine the state after the function returns.
void chart_checkButtons() {
 if(RESET()) {
 
    // check if the reset button is asserted. If the processor is already in idle, incremeet a reset timer
    // Otherwise, just enter the idle state
   if (var_state == "idle") { 
       var_resetTimer++;
    } else { 
       var_state="idle"; 
    }
 } else {
 // If the processor does not get the reset signal anymore, reset the timer to 0.
    var_resetTimer = 0;
 }

 if(STOP()) {
  var_state="stop";
 }
 if(RECORD()) {
  var_state="record";
 }
 if(PLAY_LIVE()) {
  var_state="play live";
 }
 if(PLAY_RECORDING()) {
  var_state="play recording";
 }
}


// This function is called while the reset button is asserted.
void chart_idle_event() {
   var_resetTimer=var_resetTimer+1,var_motor_1_angle=0,var_motor_2_angle=0,var_motor_1_velocity=0,var_motor_2_velocity=0,var_speaker_out=0;
   // Above several variables are set to initial values (motors must stop, speaker must stop producing sound)
   
   if ( var_resetTimer > 200) { // Number here is arbitrary, would need to be tested to find a suitable number
   // Alternatively, find a way to use a real timer and have it run for 3 seconds
       
       // TODO reset the recording data
   }
 
}


// This function runs when stop button is asserted. Simply stops the playback/dancing exactly where it is
void chart_stop_event() {
  // Does not reset motors to initial angles
 var_motor_1_velocity=0,var_motor_2_velocity=0,var_speaker_out=0;
 
  // Must also save current position in recording
}


// Function occurs while in record state
void chart_record_event() {
   // If the store button is asserted (positive edge only, must not activate several times for one press)
   // then save the selected frequency from the frequency dial in the recording
   if(!(STORE())) {
   }
}

// Function occurs while in the play live state
void chart_play_live_event() {
	current = readFrequencyInput(); //Read input from Frequency
	wait(1); //The dance button has to be pressed from two seconds
			// of the desired input(frequency)
	bool dance = pbDance; //Check if they pressed the button
	if(!PLAY_LIVE){
	chart_checkButtons(); //if the Play Live was button is not pressed
	// exit this loop and check what button is pressed or active.
	}
	if(!dance){//if the Dance Button was not pressed
	// print an error message.
	uLCD.printf("Hold the 'DANCE' Button");
	}
	if(PLAY_LIVE && dance){ //if switch=1 and dance=1
		switch(current){
		case note1: Motor.move(note1); //take the input and move the motor accordingly
        break;
        case note2: Motor.move(note2);
        break;
        case note3: Motor.move(note3);
        break;
        case note4: Motor.move(note4);
        break;
        case note5: Motor.move(note5);
        break;
        case note6: Motor.move(note6);
        break;
        case note7: Motor.move(note7);
        break;
        case note8: Motor.move(note8);
        break;
        default: uLCD_main.printf("Impossible");
		} //end 
	}
}

int readFrequencyInput(void){
	direction_FDIAL = FrequencyDial.dir(); //use the direction of the angle of the Rotary Switch 
	// Rotary Switch is continous so it have a value of 360+
	int test = value%360;
	float dummyv;
	int case_Motor;
	while(test != direction_FDIAL){
		value /= 360;
	}
		if (value >= 0 && value <= 45) {
			case_Motor = 1;
		}
		if (value >= 46 && value <= 90) {
			case_Motor = 2;
		
		}
		if (value >= 91 && value <= 135) {
			case_Motor = 3;
		
		}
		if (value >= 136 && value <= 180) {
			case_Motor = 4;
		
		}
		if (value >= 181 && value <= 225) {
			case_Motor = 5;
		
		}
		if (value >= 226 && value <= 270) {
			case_Motor = 6;
		
		}
		if (value >= 271 && value <= 315) {
			case_Motor = 7;
		
		}
		if (value >= 316 && value <= 360) {
			case_Motor = 8;
		
		}			

		return case_Motor;
	}

// Function occurs while in the play recording state
void chart_play_recording_event() {
    // Must do several things here
    // Processor must read the first value in the recording, begin playing through speaker and move the motors to the associated positions
    // Processor must have a timer for how long the recording has been playing. After some time, move to the next entry in the recording, and make the appropriate changes.
}

void print_currState(string currentState){
	int result;
	for(int i= 0; i<= stringStates.length() ; i++){
		result = strcmp(currentState,stringStates[i]); //loops through and compares each string
		if (result == 1){//if there is a match, print that out to the screen 
			wait(0.2)
			uLCD.printf("Current State in: %s\n", stringStates[i] ); //printing..
			wait(0.1)
			i = 500;//to break out of the loop
		}//end IF
	}//end FOR
}//end Function


// Entry Points and Interrupt Handlers
void setup () { peripheral_setup();  chart_SETUP(); }
void loop () { peripheral_loop(); }

